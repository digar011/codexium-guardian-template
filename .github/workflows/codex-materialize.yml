name: Codex Materializer (Guardian)

on:
  workflow_dispatch:
    inputs:
      task_id:
        description: "Codex task identifier (e.g. v4-docs-baseline)"
        required: true
        type: string
      target_path:
        description: "Target directory (e.g. docs)"
        required: true
        type: string
      files:
        description: |
          JSON object mapping filename -> file content.
          Example:
          {
            "README.md": "# Title",
            "SERVICES.md": "Content"
          }
        required: true
        type: string

permissions:
  contents: write
  pull-requests: write

# ðŸ” Global safety switch (resolved at runtime)
env:
  NEO_AUTOMATION_ENABLED: ${{ secrets.NEO_AUTOMATION_ENABLED }}

jobs:
  materialize:
    name: Materialize Codex Output
    runs-on: ubuntu-latest

    steps:
      # 0ï¸âƒ£ Guardian kill switch (MUST be first)
      - name: Guardian kill switch
        shell: bash
        run: |
          if [ "${NEO_AUTOMATION_ENABLED}" != "true" ]; then
            echo "âŒ NEO automation is disabled. Exiting."
            exit 1
          fi
          echo "âœ… NEO automation enabled. Continuing."

      # 1ï¸âƒ£ Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: true
          fetch-depth: 0

      # 2ï¸âƒ£ Clean up existing branch if it exists
      - name: Delete existing branch
        shell: bash
        continue-on-error: true
        run: |
          git push origin --delete codex/${{ inputs.task_id }} || true

      # 3ï¸âƒ£ Validate JSON payload early
      - name: Validate JSON payload
        shell: bash
        run: |
          echo '${{ inputs.files }}' | jq type > /dev/null

      # 3ï¸âƒ£ Create target directory
      - name: Create target directory
        shell: bash
        run: |
          mkdir -p "${{ inputs.target_path }}"

      # 4ï¸âƒ£ Write files (hardened)
      - name: Write files
        shell: bash
        run: |
          set -euo pipefail
          
          # Parse and write each file
          while IFS= read -r entry; do
            # Skip empty entries
            if [ -z "$entry" ]; then
              continue
            fi
            
            # Extract filename and content using jq
            filename=$(echo "$entry" | jq -r '.key')
            content=$(echo "$entry" | jq -r '.value')
            
            # Debug output
            echo "ðŸ” Processing entry:"
            echo "  Filename: '$filename'"
            echo "  Content length: ${#content} chars"
            
            # Validate filename
            if [ -z "$filename" ] || [ "$filename" = "null" ]; then
              echo "âš ï¸  Skipping entry with invalid key"
              continue
            fi
            
            # Validate content
            if [ -z "$content" ] || [ "$content" = "null" ]; then
              echo "âš ï¸  Skipping entry with empty content for: $filename"
              continue
            fi
            
            # Normalize filename
            filename=$(echo "$filename" | xargs)
            filename="${filename#/}"
            filename="${filename%/}"
            
            # Skip if empty after normalization
            if [ -z "$filename" ]; then
              echo "âš ï¸  Skipping empty filename"
              continue
            fi
            
            # Build filepath
            filepath="${{ inputs.target_path }}/${filename}"
            
            # Verify it's not a directory
            if [ -d "$filepath" ]; then
              echo "âš ï¸  Skipping existing directory: $filepath"
              continue
            fi
            
            echo "ðŸ“ Writing: $filepath"
            
            # Create parent directory
            mkdir -p "$(dirname "$filepath")"
            
            # Write file with proper newline handling
            echo -e "$content" > "$filepath"
            
            # Verify file was written
            if [ -s "$filepath" ]; then
              echo "âœ… Created: $filepath ($(wc -c < "$filepath") bytes)"
            else
              echo "âŒ WARNING: File is empty: $filepath"
            fi
          done < <(echo '${{ inputs.files }}' | jq -c 'to_entries[]')

      # 5ï¸âƒ£ Verify files were created
      - name: Verify files were created
        shell: bash
        run: |
          echo "ðŸ“‹ Files in target directory:"
          ls -la "${{ inputs.target_path }}" || echo "Directory doesn't exist or is empty"
          
          echo ""
          echo "ðŸ“Š Git status:"
          git status --short

      # 6ï¸âƒ£ Create pull request (handles commit, push, and PR)
      - name: Create pull request
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ github.token }}
          commit-message: "codex: materialize ${{ inputs.task_id }}"
          branch: codex/${{ inputs.task_id }}
          delete-branch: true
          title: "Codex: ${{ inputs.task_id }}"
          body: |
            ## Codex Materialized Output

            **Task:** ${{ inputs.task_id }}
            **Target Path:** `${{ inputs.target_path }}`

            This PR was automatically generated by **Codex Guardian**.

            - Deterministic output only
            - V4 rules enforced
            - Human approval required
            - No auto-merge
          labels: |
            codex
            guardian
            automated

      # 7ï¸âƒ£ Output PR details
      - name: PR Created
        if: steps.cpr.outputs.pull-request-number
        run: |
          echo "âœ… Pull Request #${{ steps.cpr.outputs.pull-request-number }} created"
          echo "ðŸ”— URL: ${{ steps.cpr.outputs.pull-request-url }}"

      # 8ï¸âƒ£ Handle no changes case
      - name: No Changes Detected
        if: steps.cpr.outputs.pull-request-number == ''
        run: |
          echo "â„¹ï¸ No changes detected - files may already exist with same content"
          echo "Branch pushed but no PR needed"
